.section .text
.global _start

_start:
    # Load initial hash state into a0–a7
    la s11, begin_signature
    la t0, H
    lw a0, 0(t0)
    lw a1, 4(t0)
    lw a2, 8(t0)
    lw a3, 12(t0)
    lw a4, 16(t0)
    lw a5, 20(t0)
    lw a6, 24(t0)
    lw a7, 28(t0)
    sw a0, 0(s11)	
    sw a1, 4(s11)
    sw a2, 8(s11)
    sw a3, 12(s11)
    sw a4, 16(s11)	
    sw a5, 20(s11)
    sw a6, 24(s11)
    sw a7, 28(s11)	
    addi s11, s11, 32

    # Store initial state in signature
    csrr s10, instret  				# count instructions at beginning
	
    la s0, M					# Load point to padded message
    la s1, W					# See NIST 180-4 6.2.2
    li t1, 0					# Initialize counter (t)

load_loop:
    lw t2, 0(s0)
    sw t2, 0(s1)
    addi s0, s0, 4				# increment source M ptr
    addi s1, s1, 4				# increment destination W ptr
    addi t1, t1, 1				# increment t
    sw t2, 0(s11)				# debug W[0] through W[15]
    addi s11, s11, 4	
    li t3, 16
    blt t1, t3, load_loop

    # Let's now compute W[16] to W[63]
    la s1, W
    li t1, 16

gen_loop:
    slli t2, t1, 2				# addr{W[16]} <- 16 * 4 (XLEN=32)
    add t3, s1, t2				# Compute addr{W[16]}

    lw t4, -8(t3)				# W_{t-2}
    lw t5, -28(t3)				# W_{t-7}
    lw t6, -60(t3)				# W_{t-15}
    lw t0, -64(t3)				# W_{t-16}
	
    sha256sig1 t4, t4				# Sigma1 transformation
    sha256sig0 t6, t6				# Sigma0 transofmration

    add t4, t4, t5				# temp = Sigma1+W_{t-7}
    add t4, t4, t6				# temp = temp + Sigma0
    add t4, t4, t0				# Message Schedule W_t

    sw t4, 0(t3)				# Store W_t
    sw t4, 0(s11)				# debug W_t
    addi s11, s11, 4	
	
    addi t1, t1, 1
    li t5, 64
    blt t1, t5, gen_loop

    # Working variables: s2–s9 = a-h
    mv s2, a0
    mv s3, a1
    mv s4, a2
    mv s5, a3
    mv s6, a4
    mv s7, a5
    mv s8, a6
    mv s9, a7

    sw s2, 0(s11)	
    sw s3, 4(s11)
    sw s4, 8(s11)
    sw s5, 12(s11)
    sw s6, 16(s11)	
    sw s7, 20(s11)
    sw s8, 24(s11)
    sw s9, 28(s11)	
    addi s11, s11, 32

	
    li t0, 0           				# schedule counter
    la t1, K
    la t2, W

# Compression Function
# T1 = SUM1(e) + Ch(e,f,g) + K[i] + W[i]
# T2 = SUM0(a) + Maj(a,b,c)
	
sha_round:
    slli t3, t0, 2
    add t4, t1, t3
    lw t5, 0(t4)       				# K[t]

    add t4, t2, t3
    lw t6, 0(t4)       				# W[t]

    sha256sum1 a0, s6				# Sum1 transformation
    xor a1, s6, s7
    and a1, a1, s8
    xor a1, a1, s7     				# Ch

    add a2, a0, a1
    add a2, a2, t5
    add a2, a2, t6     				# T1

    sha256sum0 a3, s2				# Sigma0 transformation
    xor a4, s2, s3
    and a4, a4, s4
    xor a4, a4, s3     				# Maj

    add a5, a3, a4     				# T2

    # Compression Function Shift
#    mv a6, s9					# H6=h
    mv s9, s8					# h
    mv s8, s7					# g
    mv s7, s6					# f
    add s6, s5, a2				# e = d+T1
    mv s5, s4					# d
    mv s4, s3					# c
    mv s3, s2					# b
    add s2, a2, a5				# a = T1+T2

    sw s2, 0(s11)	
    sw s3, 4(s11)
    sw s4, 8(s11)
    sw s5, 12(s11)
    sw s6, 16(s11)	
    sw s7, 20(s11)
    sw s8, 24(s11)
    sw s9, 28(s11)	
    addi s11, s11, 32

	
    addi t0, t0, 1
    li a7, 2
    blt t0, a7, sha_round

    # Intermediate Hash (e.g., H_0^i = a + H_0^{i-1})
    add a0, a0, s2				# H0
    add a1, a1, s3				# H1
    add a2, a2, s4				# H2
    add a3, a3, s5				# H3
    add a4, a4, s6				# H4
    add a5, a5, s7				# H5
    add a6, a6, s8				# H6
    add a7, a7, s9				# H7

    # Store result in signature
    sw a0, 0(s11)	
    sw a1, 4(s11)
    sw a2, 8(s11)
    sw a3, 12(s11)
    sw a4, 16(s11)	
    sw a5, 20(s11)
    sw a6, 24(s11)
    sw a7, 28(s11)	
    addi s11, s11, 32
	
# Finalize
done:
    csrr s9, instret       			# Read instruction count
    sub s9, s9, s10	        		# get number of #instructions executed	
    sw s9, 0(s11)	
	
write_tohost:
    la t1, tohost
    li t0, 1               			# Success code
    sw t0, 0(t1)           			# Send success code

self_loop:
    j self_loop

.section .tohost
tohost:
    .word 0
fromhost:
    .word 0

.data
.align 4

.EQU XLEN,32
begin_signature:
    .fill (64+2*8)*(XLEN/32),4,0xdeadbeef
end_signature:

# Initial SHA-256 hash values (NIST 180-4 5.3.3)
H:
#    .word 0x67e6096a, 0x85ae67bb, 0x72f36e3c, 0x3af54fa5
#    .word 0x7f520e51, 0x8c68059b, 0xabd9831f, 0x19cde05b
    .word 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a
    .word 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    
# K constants for SHA-256 (NIST 180-4 4.2.2)
K:
    .word 0x982f8a42, 0x91443771, 0xcffbc0b5, 0xa5dbb5e9
    .word 0x5bc25639, 0xf111f159, 0xa4823f92, 0xd55e1cab
    .word 0x98aa07d8, 0x015b8312, 0xbe853124, 0xc37d0c55
    .word 0x745dbe72, 0xfeb1de80, 0xa706dc9b, 0x74f19bc1

    .word 0xc1699be4, 0x8647beef, 0xc69dc10f, 0xcca10c24
    .word 0x6f2ce92d, 0xaa84744a, 0xdca9b05c, 0xda88f976
    .word 0x52513e98, 0x6dc631a8, 0xc82703b0, 0xc77f59bf
    .word 0xf30be0c6, 0x4791a7d5, 0x5163ca06, 0x67292914

    .word 0x850ab727, 0x38211b2e, 0xfc6d2c4d, 0x130d3853
    .word 0x54730a65, 0xbb0a6a76, 0x2ec9c281, 0x852c7292
    .word 0xa1e8bfa2, 0x4b661aa8, 0x708b4bc2, 0xa3516cc7
    .word 0x19e892d1, 0x240699d6, 0x85350ef4, 0x70a06a10

    .word 0x16c1a419, 0x086c371e, 0x4c774827, 0xb5bcb034
    .word 0xb30c1c39, 0x4aaa8a4e, 0x4fca9c5b, 0xf36f2e68
    .word 0xee828f74, 0x6f63a578, 0x1487c884, 0x0802c78c
    .word 0xfaffbe90, 0xeb6c50a4, 0xf7a3f9be, 0xf27871c6

# One padded 512-bit block for message "Go Wally!" 
M:
    .word 0x476f2057, 0x616c6c79, 0x21800000, 0x00000000
    .word 0x00000000, 0x00000000, 0x00000000, 0x00000000
    .word 0x00000000, 0x00000000, 0x00000000, 0x00000000
    .word 0x00000000, 0x00000000, 0x00000000, 0x00000048

# Space for W[0..63] (64 x 4 bytes)	
W:
     .skip 256   


.bss
    .space 512

	
